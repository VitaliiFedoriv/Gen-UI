import json
from typing import List, Literal, Optional, TypedDict

from langchain.output_parsers.openai_tools import JsonOutputToolsParser
from langchain.pydantic_v1 import BaseModel, Field, datetime
from langchain_core.messages import AIMessage, HumanMessage
from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder
from langchain_core.runnables import RunnableConfig
from langchain_openai import ChatOpenAI
from langgraph.graph import END, StateGraph
from langgraph.graph.graph import CompiledGraph

from gen_ui_backend.charts.schema import (
    ChartType,
    DataDisplayTypeAndDescription,
    Filter,
    Order,
    filter_schema,
)


class AgentExecutorState(TypedDict, total=False):
    input: HumanMessage
    """The user input"""
    display_formats: List[DataDisplayTypeAndDescription]
    """The types of display formats available for the chart."""
    orders: List[Order]
    """List of orders to process."""
    selected_filters: Optional[List[Filter]]
    """The filters generated by the LLM to apply to the orders."""
    chart_type: Optional[ChartType]
    """The type of chart which this format can be displayed on."""
    display_format: Optional[str]
    """The format to display the data in."""
    props: Optional[dict]
    """The props to pass to the chart component."""


def format_data_display_types_and_descriptions(
    data_display_types_and_descriptions: List[DataDisplayTypeAndDescription],
) -> List[str]:
    return [
        f"Data display type: {item.name}. Chart type: {item.chart_type}. Description: {item.description}"
        for item in data_display_types_and_descriptions
    ]


def generate_filters(state: AgentExecutorState) -> AgentExecutorState:
    prompt = ChatPromptTemplate.from_messages(
        [
            (
                "system",
                """You are a helpful assistant. Your task is to determine the proper filters to apply, give a user input.
  The user input is in response to a 'magic filter' prompt. They expect their natural language description of the filters to be converted into a structured query.""",
            ),
            MessagesPlaceholder("input"),
        ]
    )
    product_names: List[str] = list(
        set(order.product_name.lower() for order in state.orders)
    )
    schema = filter_schema(product_names)

    model = ChatOpenAI(model="gpt-4o", temperature=0).with_structured_output(
        schema=schema
    )
    chain = prompt | model
    result = chain.invoke(input=state.input)

    return {
        "selected_filters": result,
    }


def generate_chart_type(state: AgentExecutorState) -> AgentExecutorState:
    prompt = ChatPromptTemplate.from_messages(
        [
            (
                "system",
                """You are an expert data analyst. Your task is to determine the best type of chart to display the data based on the filters and user input.
  You are provided with three chart types: 'bar', 'line', and 'pie'.
  The data which is being filtered is a set of orders from an online store.
  The user has submitted an input that describes the filters they'd like to apply to the data.
  
  Keep in mind that each chart type has set formats to display the data. You should consider the best display format when selecting your chart type.
  
  Data display types: {data_display_types_and_descriptions}
  
  Based on their input and the filters that have been generated, select the best type of chart to display the data.""",
            ),
            (
                "human",
                """Magic filter input: {magic_filter_input}
  
  Generated filters: {selected_filters}""",
            ),
        ]
    )

    class ChartTypeSchema(BaseModel):
        """Choose the best type of chart to display the data, based on the filters, user request, and ways to display the data on a given chart."""

        chart_type: Literal["bar", "line", "pie"] = Field(
            ..., description="The type of chart to display the data."
        )

    model = ChatOpenAI(model="gpt-4o", temperature=0).with_structured_output(
        schema=ChartTypeSchema()
    )
    chain = prompt | model
    result = chain.invoke(
        magic_filter_input=state.input.content,
        selected_filters=json.dumps(state.selected_filters),
        data_display_types_and_descriptions=format_data_display_types_and_descriptions(
            state.display_formats
        ),
    )

    return {
        "chart_type": result.chart_type,
    }


def generate_data_display_format(state: AgentExecutorState) -> AgentExecutorState:
    prompt = ChatPromptTemplate.from_messages(
        [
            (
                "system",
                """You are an expert data analyst. Your task is to determine the best format to display the data based on the filters, chart type and user input.
  
  The type of chart which the data will be displayed on is: {chart_type}.
  
  This chart has the following formats of which it can display the data: {data_display_types_and_descriptions}.
  
  The user will provide you with their original input to the 'magic filter' prompt, and the filters which have been generated based on their input.
  You should use these inputs as context when making a decision on the best format to display the data.
  
  Select the best display format to show the data based on the filters, chart type and user input.""",
            ),
            (
                "human",
                """Magic filter input: {magic_filter_input}
  
  Generated filters: {selected_filters}""",
            ),
        ]
    )

    class DataDisplayFormatSchema(BaseModel):
        """Choose the best format to display the data based on the filters and chart type."""

        display_format: str = Field(
            ...,
            description=f"The format to display the data in. Must be one of {', '.join([item.name for item in state.display_formats])}",
        )

    model = ChatOpenAI(model="gpt-4o", temperature=0).with_structured_output(
        schema=DataDisplayFormatSchema()
    )
    chain = prompt | model
    result = chain.invoke(
        chart_type=state.chart_type,
        magic_filter_input=state.input.content,
        selected_filters=json.dumps(state.selected_filters),
        data_display_types_and_descriptions=format_data_display_types_and_descriptions(
            state.display_formats
        ),
    )

    return {
        "display_format": result.display_format,
    }


def filter_data(state: AgentExecutorState) -> AgentExecutorState:
    selected_filters = state.selected_filters
    orders = state.orders

    product_names = selected_filters.get("product_names")
    before_date = selected_filters.get("before_date")
    after_date = selected_filters.get("after_date")
    min_amount = selected_filters.get("min_amount")
    max_amount = selected_filters.get("max_amount")
    order_state = selected_filters.get("state")
    city = selected_filters.get("city")
    discount = selected_filters.get("discount")
    min_discount_percentage = selected_filters.get("min_discount_percentage")
    status = selected_filters.get("status")

    if min_discount_percentage is not None and discount is False:
        raise ValueError(
            "Can not filter by min_discount_percentage when discount is False."
        )

    filtered_orders = []
    for order in orders:
        is_match = True

        if product_names and order.product_name.lower() not in product_names:
            is_match = False
        if before_date and order.ordered_at > before_date:
            is_match = False
        if after_date and order.ordered_at < after_date:
            is_match = False
        if min_amount is not None and order.amount < min_amount:
            is_match = False
        if max_amount is not None and order.amount > max_amount:
            is_match = False
        if order_state and order.address.state.lower() != order_state.lower():
            is_match = False
        if city and order.address.city.lower() != city.lower():
            is_match = False
        if discount is not None and (order.discount is None) != discount:
            is_match = False
        if min_discount_percentage is not None and (
            order.discount is None or order.discount < min_discount_percentage
        ):
            is_match = False
        if status and order.status.lower() != status.lower():
            is_match = False

        if is_match:
            filtered_orders.append(order)

    return {"orders": filtered_orders}


def create_graph() -> CompiledGraph:
    workflow = StateGraph(AgentExecutorState)

    # Add nodes
    workflow.add_node("generate_filters", generate_filters)
    workflow.add_node("generate_chart_type", generate_chart_type)
    workflow.add_node("generate_data_display_format", generate_data_display_format)
    workflow.add_node("filter_data", filter_data)

    # Add edges
    workflow.add_edge("generate_filters", "generate_chart_type")
    workflow.add_edge("generate_chart_type", "generate_data_display_format")
    workflow.add_edge("generate_data_display_format", "filter_data")

    # Set entry and finish points
    workflow.set_entry_point("generate_filters")
    workflow.set_finish_point("filter_data")

    graph = workflow.compile()
    return graph
